{| border="1" cellpadding="2" cellspacing="0"
| <tablestyle="width:95%; text-align:center; font-size:2.2em; font-weight:bold; border:hidden">Git 用户手册中文版
| 
|}
 .<i>Translator:</i> <b>罗峥嵘 (Robin Steven)</b> <vortune@gmail.com>
-----

= Preface 前言 =

Git is a fast distributed revision control system.

Git 是一个快速的分布式版本控制系统

This manual is designed to be readable by someone with basic UNIX command-line skills, but no previous knowledge of git.

这个手册是面向那些具有基本的 Unix 命令行使用技能，但是没有 Git 知识的人设计的。 

Chapter 1, Repositories and Branches and Chapter 2, Exploring git history explain how to fetch and study a project using git—read these chapters to learn how to build and test a particular version of a software project, search for regressions, and so on.

第一章 版本库与分支 和 第二章 考查 git 历史 将展示如何用 git 来获取和研究一个项目，通过阅读这些章节，我们学习如何建立和测试一个具体的软件项目的版本，学习“撤退”等等。

People needing to do actual development will also want to read Chapter 3, Developing with git and Chapter 4, Sharing development with others.

人们是需要开展真正的研发工作的，那么就学习 第三章， 用 git 进行开发 和 第四章，与他人共享研发成果。

Further chapters cover more specialized topics.

更多的一些章节会涉及到许多的专题话题。

Comprehensive reference documentation is available through the man pages, or git-help(1) command. For example, for the command "git clone <repo>", you can either use:

参考文档可以通过系统的手册页命令，或者是 git-help(1) 命令来查看。譬如，你想参考 "git clone <repo>"， 你可以用下面的两种方式：

<pre><nowiki>
$ man git-clone
</nowiki></pre>

or:
或者：

<pre><nowiki>
$ git help clone
</nowiki></pre>

With the latter, you can use the manual viewer of your choice; see git-help(1) for more information.

晚一点你就有机会用到这些手册查看器的；看 git-help(1) 会得到比较多的信息。

See also Appendix A, Git Quick Reference for a brief overview of git commands, without any explanation.

阅读 附录A，那里是一个 git 命令的快速纵览，但是它不带任何的解说。

Finally, see Appendix B, Notes and todo list for this manual for ways that you can help make this manual more complete.

最后，看看 附录B，这份手册的笔记和工作表，通过它你可以帮助这份文档变得更完善。

= Chapter 1. Repositories and Branches 第一章，版本库与分支 =

== How to get a git repository 如何获取一个版本库 ==

It will be useful to have a git repository to experiment with as you read this manual.

有一个实验性的 git 版本库对我们阅读这份手册将非常有用。

The best way to get one is by using the git-clone(1) command to download a copy of an existing repository. If you don't already have a project in mind, here are some interesting examples:

获取一个已经存在的版本库，最佳的方法是用 git-clone 命令，如果你还没有什么心目中的项目的话，那么这里有些有趣的例子：

<pre><nowiki>
        # git itself (approx. 10MB download):
$ git clone git://git.kernel.org/pub/scm/git/git.git
        # the Linux kernel (approx. 150MB download):
$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
</nowiki></pre>

The initial clone may be time-consuming for a large project, but you will only need to clone once.

对于一个大型项目来说，初始性的克隆是挺费时的，不过克隆只需要做一次。

The clone command creates a new directory named after the project ("git" or "linux-2.6" in the examples above). After you cd into this directory, you will see that it contains a copy of the project files, called the working tree, together with a special top-level directory named ".git", which contains all the information about the history of the project.

克隆命令会创建一个新的目录，并根据项目的名称来命名这个项目（譬如上说例子中的 “git” 和 “linux-2.6”）。当你进入这个目录的时候，你可以看到它已经包含了项目中的所有文件，我们称之为工作树，在顶层目录中还连带了一个叫 ".git" 的特殊的目录，里面包含了项目的发展历史的所有信息。

== How to check out a different version of a project 如何提取项目的不同版本 ==

Git is best thought of as a tool for storing the history of a collection of files. It stores the history as a compressed collection of interrelated snapshots of the project's contents. In git each such version is called a commit.

最好将 git 当作是文件发展的历史纪录的收集工具，它压缩并保存了项目的发展的关联性快照。在 git 中，每个这些变更称作交付(commit)。

Those snapshots aren't necessarily all arranged in a single line from oldest to newest; instead, work may simultaneously proceed along parallel lines of development, called branches, which may merge and diverge.

这些快照并不需要按从旧到新单线索地发展；它可以是同步并行地发展的，称之为分支，它们是可以合并和分割的。

A single git repository can track development on multiple branches. It does this by keeping a list of heads which reference the latest commit on each branch; the git-branch(1) command shows you the list of branch heads:

一个 git 版本库可以跟踪多个分支的发展，它通过保存一个分支头列表的方式来做到这一点，每个分支头都是一个引用(reference)，它指向该分支最后的一个交付(commit)； git-branch(1) 命令可以向你展示每个分支头：

<pre><nowiki>
$ git branch
* master
</nowiki></pre>

A freshly cloned repository contains a single branch head, by default named "master", with the working directory initialized to the state of the project referred to by that branch head.

一个刚刚克隆的版本库只包含一个分支头，默认叫 “master” （主分支），并且工作目录已经被初始化为这个分支头所指向的项目状态。

Most projects also use tags. Tags, like heads, are references into the project's history, and can be listed using the git-tag(1) command:

大部分的项目还用到标签（tags）。标签（Tags）就好像头（heads），它指向项目的某个历史场面，它们可以通过 git-tag(1) 命令列举出来：

<pre><nowiki>
$ git tag -l
v2.6.11
v2.6.11-tree
v2.6.12
v2.6.12-rc2
v2.6.12-rc3
v2.6.12-rc4
v2.6.12-rc5
v2.6.12-rc6
v2.6.13
...
</nowiki></pre>

Tags are expected to always point at the same version of a project, while heads are expected to advance as development progresses.

Tags 被当做是项目统一的版本来对待，而 heads 则是项目前进的每一个步伐。

Create a new branch head pointing to one of these versions and check it out using git-checkout(1):

下面创建一个新的分支头，使其指向其中的某个版本，同时将它提取出来，可以用 git-checkout(1) 命令：

<pre><nowiki>
$ git checkout -b new v2.6.13
</nowiki></pre>

The working directory then reflects the contents that the project had when it was tagged v2.6.13, and git-branch(1) shows two branches, with an asterisk marking the currently checked-out branch:

工作目录将被镜像为项目中标记为 v2.6.13 的版本的内容，用 git-branch(1) 命令展示这个两个分支，前面带星号(*)的就是当前抽取的分支。

<pre><nowiki>
$ git branch
  master
* new
</nowiki></pre>

If you decide that you'd rather see version 2.6.17, you can modify the current branch to point at v2.6.17 instead, with

如果你打算看看 2.6.17 的版本，你可以迁移你当前的分支，让它指向 2.6.17, 使用一下命令：

<pre><nowiki>
$ git reset --hard v2.6.17
</nowiki></pre>

Note that if the current branch head was your only reference to a particular point in history, then resetting that branch may leave you with no way to find the history it used to point to; so use this command carefully.

注意，如果当前的分支头是你唯一的指向具体的历史场面的引用的话，那么复位 (resetting) 这个分支将令你无法找回这个分支以前的所有历史纪录，所以这个命令要慎用。

== Understanding History: Commits 理解历史： 交付 ==

Every change in the history of a project is represented by a commit. The git-show(1) command shows the most recent commit on the current branch:

项目的每一个历史变更体现为每一个交付 (commit)。git-show(1) 命令展示当前分支的最新交付：

<pre><nowiki>
$ git show
commit 17cf781661e6d38f737f15f53ab552f1e95960d7
Author: Linus Torvalds <torvalds@ppc970.osdl.org.(none)>
Date:   Tue Apr 19 14:11:06 2005 -0700

    Remove duplicate getenv(DB_ENVIRONMENT) call

    Noted by Tony Luck.

diff --git a/init-db.c b/init-db.c
index 65898fa..b002dc6 100644
--- a/init-db.c
+++ b/init-db.c
@@ -7,7 +7,7 @@

 int main(int argc, char **argv)
 {
-       char *sha1_dir = getenv(DB_ENVIRONMENT), *path;
+       char *sha1_dir, *path;
        int len, i;

        if (mkdir(".git", 0755) < 0) {
</nowiki></pre>

As you can see, a commit shows who made the latest change, what they did, and why.

正如你看到的那样，交付表明了谁做的最后的更改，改了什么，为什么改。

Every commit has a 40-hexdigit id, sometimes called the "object name" or the "SHA1 id", shown on the first line of the "git-show" output. You can usually refer to a commit by a shorter name, such as a tag or a branch name, but this longer name can also be useful. Most importantly, it is a globally unique name for this commit: so if you tell somebody else the object name (for example in email), then you are guaranteed that name will refer to the same commit in their repository that it does in yours (assuming their repository has that commit at all). Since the object name is computed as a hash over the contents of the commit, you are guaranteed that the commit can never change without its name also changing.

每个交付都有一个40个16进制字符的标识号，称为 “对象名” 或者叫 “SHA1 id”，它显示在 git-show 命令的输出的第一行中。你通常可以用较简短的名字来指明一个交付，譬如标签和分支的名称等等，但是这个长长的名字是很有用的。最重要的是，对于某个交付来说它是全局唯一的名字： 譬如你告诉其他人某个对象名（通过 email等方式），那么你需要确保这个名字不管是在你的版本库中，还是在他们的版本库中都是指向同一个交付的（假设他们的版本库也被交付了很多东西）。当对象名根据每个交付的内容通过哈希算法（hash）算出之后，你就可以确保每个交付中的内容的修改，都不可能脱离它的名字。

In fact, in Chapter 7, Git concepts we shall see that everything stored in git history, including file data and directory contents, is stored in an object with a name that is a hash of its contents.

事实上，在 第七章，Git 的概念 中，我们可以看到保存在 git 历史中的所有东西，包括文件数据与目录内容都会被保存为对象，对象名就是他们的内容的哈希特征值。

=== Understanding history: commits, parents, and reachability 理解历史： 交付，父交付与可及性 ===

Every commit (except the very first commit in a project) also has a parent commit which shows what happened before this commit. Following the chain of parents will eventually take you back to the beginning of the project.

每个交付（除非是项目的第一个交付）总是有他的父交付，这样就说明了到当前的交付为止到底发生过什么。追索父交付链，可以将我们带回项目的起始点。

However, the commits do not form a simple list; git allows lines of development to diverge and then reconverge, and the point where two lines of development reconverge is called a "merge". The commit representing a merge can therefore have more than one parent, with each parent representing the most recent commit on one of the lines of development leading to that point.

无论如何，这些交付的组织形式都不会是简单的；git 容许开发路线可以分道扬镳，也可以殊途同归，两条开发线路的结合点我们叫“合并”（merge）。表示合并的交付就等于有一个以上的父交付了，每个父交付表示每个开发线路发展到这里的最贴近的交付。

The best way to see how this works is using the gitk(1) command; running gitk now on a git repository and looking for merge commits will help understand how the git organizes history.

最好的查看这个机制的方法是用 gitk(1) 命令；现在在版本库中运行 gitk 命令，并查看一下那些合并交付会对你理解 git 是如何组织历史的会有帮助。

In the following, we say that commit X is "reachable" from commit Y if commit X is an ancestor of commit Y. Equivalently, you could say that Y is a descendant of X, or that there is a chain of parents leading from commit Y to commit X.

接着，我们说 交付X 对于 交付Y 来说是“可及的”， 如果 交付X 是 交付Y 的祖先的话。同样地，你可以说 Y 是 X 的一个后裔， 或者说存在一个从 Y 追索到 X 的世系族谱。

__NOTOC__