== 创建一个 Git 版本库 ==

<pre><nowiki>
$ cd project/
$ git init          # 创建 .git 目录 ( 1.4.4.4 版本之后用这个命令 )
$ git add .         # 将那些未被跟踪的文件加入版本库中
$ git commit        # 将工作目录的变化提交到版本库中
</nowiki></pre>

Git 将根据在版本库根目录中的 [[.gitignore]] 文件中列出的文件名，
忽略对那些文件的跟踪， 文件和目录名，可以用 shell 正则表达式来表示。

== 分支于合并 ==

<pre><nowiki>
$ git checkout -b linux-work  # 创建一个名叫 "linux-work" 的分支
$ <make changes>
$ git commit -a
$ git checkout master         # 回到主分支
$ git merge linux-work        # 将在 linux-work 分支上的变更集合并入 master 分支 
                              # (适用于 Git 1.5 以上版本)
$ git pull . linux-work       # 将在 linux-work 分支上的变更集合并入 master 分支 
                              # (适用于 Git 的所有版本)
</nowiki></pre>

== 引入补丁 ==

<pre><nowiki>
$ git apply < ../p/foo.patch
$ git commit -a
</nowiki></pre>

== 生成补丁 ==

<pre><nowiki>
$ <make changes>
$ git commit -a -m "commit message"
$ git format-patch HEAD^  # 生成一个 0001-commit-message.patch 的文件
                          # ( 这里的意思是生成当前分支的最新版本到他的父版本 HEAD^ 
                          # 的所有文件的补丁，当然你应该知道 HEAD 的概念是什么 )
</nowiki></pre>

== 网络功能 ==

<pre><nowiki>
# 从主版本库中克隆
foo$ git clone git://git.kernel.org/pub/scm/git/git.git
foo$ cd git

# 将本地变更推入远程版本库
foo$ git push user@example.com:my-repository.git/

# 抓取远程版本库中的其中一个分支到本地版本库
foo$ git fetch user@example.com:my-repository.git/ remote-branch:local-branch

# 将远程版本库中的变化合并到本地
bar$ git pull git://foo/repo.git/ branch

# 用 git 协议建立版本库服务
foo$ cd /my/repository/
foo$ touch .git/git-daemon-export-ok
foo$ git daemon  # 这样其他人就可以通过 git://your.machine/my/repository/.git/ 来抓取版本库

# 建立一个裸版本库( 没有工作目录的 )
foo$ mkdir my-repo.git
foo$ cd my-repo.git
foo$ git --bare init
foo$ chmod a+x .git/hooks/post-update # 用 HTTP 协议来传输版本时要这样
                                      # 并且你需要用 push 命令来植入你的版本库的内容
</nowiki></pre>

== Inspecting revisions ==

<pre><nowiki>
# inspect history visually
foo$ gitk       # this opens a Tk window, and shows you how the revisions are connected

# inspect history
foo$ git log    # this pipes a log of the current branch into your PAGER
foo$ git log -p # ditto, but append a patch after each commit message

# inspect a specific commit
foo$ git show HEAD    # show commit info, diffstat and patch
                      # of the tip of the current branch
</nowiki></pre>

== Referring to revisions ==

<pre><nowiki>
# by name
foo$ git log v1.0.0   # show history leading up to tag "v1.0.0"
foo$ git log master   # show history of branch "master"

# relative to a name
foo$ git show master^   # show parent to last revision of master
foo$ git show master~2  # show grand parent to tip of master
foo$ git show master~3  # show great grand parent to tip of master (you get the idea)

# by output of "git describe"
foo$ git show v1.4.4-g730996f  # you get this string by calling "git describe"

# by hash (internally, all objects are identified by a hash)
foo$ git show f665776185ad074b236c00751d666da7d1977dbe
foo$ git show f665776   # a unique prefix is sufficient

# tag a revision
foo$ git tag v1.0.0                      # make current HEAD known as "v1.0.0"
foo$ git tag interesting v1.4.4-g730996f # tag a specific revision (not HEAD)
</nowiki></pre>

== Comparing revisions ==

<pre><nowiki>
# diff between two branches
foo$ git diff origin..master            # pipes a diff into PAGER
foo$ git diff origin..master > my.patch # pipes a diff into my.patch

# get diffstat of uncommitted work
foo$ git diff --stat HEAD
</nowiki></pre>

== Cherry picking patches ==

<pre><nowiki>
foo$ git cherry-pick other-branch~3     # apply 4th last patch of other-branch to current branch
</nowiki></pre>
----
[[CategoryGitDocumentation]]

__NOTOC__