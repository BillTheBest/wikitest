= Git Survey summary =
(I'm going to summarize git survey incrementally here)
Note that count is not exactly number of people.

== 1. What country are you in? ==
<pre><nowiki>#!CSV
      Count;Country
      3;Australia
      2;Austria 
      1;Belarus 
      2;Brazil 
      1;British Isles 
      3;Canada 
      1;Chile 
      2;China 
      2;Czech Republic 
      4;Denmark 
      2;England 
      1;Estonia
      1;Europe 
      5;Finland 
      6;France 
     14;Germany 
      1;Indian 
      3;Italy 
      1;Lithuania
      3;Netherlands 
      1;Norway 
      1;Philippines 
      3;Poland 
      2;Russia 
      1;South Africa 
      2;Spain 
      6;Sweden 
      1;Switzerland 
      1;UAE 
      5;United Kingdom 
     34;United States 
      1;Vietnam 
</nowiki></pre>
== 2. What is your preferred non-programming language? ==
<pre><nowiki>#!CSV
      Count;Language
      1;Belarusian 
      1;Chinese 
      2;Czech 
      5;Danish 
      4;Dutch 
     70;English 
      1;Estonian 
      4;Finnish 
      5;French 
     12;German 
      3;Italian 
      1;Japanese 
      3;Polish 
      4;Russian 
      4;Spanish 
      5;Swedish 
      1;Vietnamese 
</nowiki></pre>

== 3. How did you hear about GIT? ==
<pre><nowiki>#!CSV
      Count;Answer
      4; Friends 
      1; GCC 
      5; Either  Carl Worth, Keith Packard, David Greaves, Pasky, Jonas
      1; I wrote it
      5; KernelTrap 
      2; linuxppc-embedded 
     73; LKML 
     11; LWN 
      1; Monotone 
      6; Other 
      5; Slashdot 
      1; The Register 
      2; U-Boot 
      3; Xorg 
</nowiki></pre>

== 4. Did you find GIT easy to learn? ==
<pre><nowiki>#!CSV
  Count;Answer
  6 ; Very easy 
  21 ; Easy 
  64 ; Reasonably 
  22 ; Hard 
  3 ; Very hard 
</nowiki></pre>

== 5. What helped you most in learning to use it? ==
<pre><nowiki>#!CSV
      Count;Answer
      5; GIT code 
      8; Cogito 
      5; Carl Worth, Keith Packard, Pasky, Jeff Garzik
     37; documentation (including online tutorials..)
      4; Everyday GIT 
      7; examples 
      4; experience 
      3; friends 
      3; #git 
      1; gitk 
      5; google
     27; man pages 
     17; mailing list (both git and lkml) 
      1; Ottawa (OLS) tutorials 
      11; practice 
      1; time 
      2; Git wiki 
      1; Wine wiki 
      1; Writing pg, a StGit-like patch stack frontend to GIT. 
      1; Writing StGIT 
</nowiki></pre>

== 6. What did you find hardest? ==

Note: "poor documetation" is not mentioned here. Please grep -i "doc" for it.

<pre><nowiki>#!CSV
     Count;Summary;Detail
     28;too many commands;The "too many commands" usually because mixing of porcelain commands and low-level commands. Also there are complaints about too many command options, some doesn't have enough documentation such as git-diff-*
     19;index;there is a suggestion to refer it as "cache" for easier understanding. Another mentioned about the index manipulation after a "git reset --soft".
      8;merge; and merge conflict, why merge fails
      7;distributed nature;
      4;comparison with other vcs; about (esspecially) concepts, workflow, commands...
      3;push/pull;
      3;git concepts; blobs, trees, commits..
      4;error messages;not descriptive enough to identify the source of errors, "empty commit" message
      3;cherry picking; one recommended StGIT
      2;setting up the remote repository;
      2;git work flow;
      1;refspec;
      1;rebase;
      1;Network protocol changes;
      1;topic branches; examples?
      1;git vs cogito;
      1;branches vs tags;
      1;branches;
      1;bisect;
      1;;GIT repository via a strict firewall
      1;;Working out which commands operated on the working tree, which on the index, and which on commits (e.g. git diff).
      1;;Understand the check-in and check-out stuff.
      1;;Understanding where the patch repositories are located, and how to determine patch order. 
      1;;The fact git will let you destroy your work trivially, the poor design of the merge system.
      1;;Still not confidant in doing anything other than cloning
      1;;how to reorder fixes and cherrypick fixes from my other temporary git trees
      1;;git diff not showing diff for files updated to index
      1;;Generating mail with all the patches created
      1;;Accidentally commiting master branch Difference between pull/commit
</nowiki></pre>

== 7. When did you start using git? ==

In summary, there are 18 started using GIT from the beginning. 47 others started in 2005. 42 started in 2006. One started using from GIT v0.9, one from 0.98, one from 1.0. Two started from elinks git conversion. See the below table for details.

<pre><nowiki>#!CSV
      Count;Time
      1;GIT 0.9
      1;GIT 0.98
      1;GIT 1.0
      9;Sometime in 2005
      1;200502
      3;200504
      4;200505
      6;200506
      1;200507
      6;200508
      6;200509
      5;200510
      1;200511
      2;200512
      1;2005 Q2
      2;2005 Q3
      3;Sometime in 2006
      8;200601
      4;200602
      2;200603
      5;200604
      7;200605
      4;200606
      6;200607
      1;2006 Q1
      2;elinks conversion
      1;git-pasky-0.3
     17;From the beginning
      1;Cogito annoucement
      1;xcb conversion 200602
      1;Xorg conversion
</nowiki></pre>

== 8. How you use GIT? Do you use GIT for ... ==
<pre><nowiki>#!CSV
   Count;Purpose
   14;Work
   50;Unpaid projects
   52;Both
</nowiki></pre>

== 9. How do you obtain GIT ==
<pre><nowiki>#!CSV
   Count; Method
   32;Source tarball
   31;Binary package
   53;Pull from main repository
</nowiki></pre>

== 10. What hardware platforms do you use GIT on? ==
Some hardwares I'm not sure, so left them as is. If you know them, please edit the table.

<pre><nowiki>#!CSV
      Count;Architecture
      1;alpha
     15;amd64
      1;Apple iBook
      1;Apple PowerBook G4 1.5GHz Quantex Laptop P3 400MHz
      1;arm
    100;ia32
      3;ia64
      1;IBM ThinkPad laptop, 64 MB
      1;mac ibook g4
      1;parisc
      1;PC Laptop IBM T30
     12;ppc
      2;ppc64
      1;power3
      1;power4
      1;SGI Onyx 2
      6;sparc
      3;sparc64
      1;x64_32
      1;x64_64
     23;x86_64
</nowiki></pre>

== 11. What OS (please include the version) do you use GIT on? ==
Most is Linux. 14 for Cygwin. 4 for FreeBSD. One for IRIX, NetBSD and HP-UX. 10 for Mac OS X. 3 for Solaris.

<pre><nowiki>#!CSV
Count;OS
      1; AIX
      7; Cygwin
      2; Cygwin Windows 2000
      3; Cygwin Windows XP
      1; Cygwin Windows XP Professional
      1; Cygwin Windows XP SP2
      1; Darwin 8.6.0
      1; FreeBSD
      1; FreeBSD 6.0
      1; FreeBSD 6-stable
      1; FreeBSD 7-current
      1; HP-UX 11i
      1; IRIX
      3; Mac OS X
      1; Mac OS X 10.3
      1; Mac OS X 10.3.9
      1; Mac OS X 10.4
      2; Mac OS X 10.4
      1; Mac OS X 10.4.6
      1; Mac OS X 10.4.7
      1; NetBSD 3.0
      2; Solaris
      1; Solaris 10
      1; Solaris 9
</nowiki></pre>

Linux table

<pre><nowiki>#!CSV
Count;Distro
     15; Linux
      4; Linux 2.4
     17; Linux 2.6
      2; Linux Arch
      4; Linux Debian
     12; Linux Debian Etch
      4; Linux Debian Sarge
     18; Linux Debian Sid
      6; Linux Debian Stable
      1; Linux FC
      2; Linux FC2
      4; Linux FC3
      4; Linux FC4
     11; Linux FC5
      1; Linux FC6
      3; Linux FC Rawhide
      9; Linux Gentoo
      1; Linux Gentoo 2005.1
      1; Linux Gentoo 2006.1
      1; Linux Mandrake 2005LE
      1; Linux Mandriva 2006
      1; Linux OpenSuSE
      1; Linux Red Hat 6.2
      2; Linux Red Hat 8.0
      1; Linux RHEL
      1; Linux RHEL3
      1; Linux RHEL4
      1; Linux Slackware
      4; Linux Slackware 10.2
      1; Linux Slackware-current
      1; Linux Slackware-current
      1; Linux slamd64 10.1
      2; Linux SLED 10
      2; Linux SLES 10
      1; Linux SLES 9
      1; Linux SLES 9 SP3
      4; Linux SuSE
      1; Linux Ubuntu
      1; Linux Ubuntu 5.10
     14; Linux Ubuntu 6.06
      1; Linux Ubuntu 6.10
      1; Linux Ubuntu breezy
      1; Linux Ubuntu hoary
      1; Linux Ubuntu warty
</nowiki></pre>

== 12. How many people do you collaborate with using GIT? ==
<pre><nowiki>#!CSV
     32;0
      6;1
     10;2
      9;3
      5;4
      9;5
      1;6
      2;7
      7;10
      1;12
      2;15
      3;20
      2;25
      1;30
      1;40
      1;80
      2;cairo ~25
      4;Linux
      2;U-Boot
      1;v4l-dvb
      1;Wine
      1;XCB
      1;XCB ~10
      2;xorg ~50
</nowiki></pre>

== 15. Which porcelains do you use? ==
<pre><nowiki>#!CSV
Count;Porcelain
     21;cogito (maybe plus git-format-patch, gitk, tig, qgit)
     61;git
      4;gitk or gitweb
      2;pg
      5;qgit
     10;stgit
</nowiki></pre>

== 16. Is the git.git repository including codes produced by you? ==
72 say no. 34 say yes.

== 17. What you think of GIT? Overall, how happy are you with GIT? ==
(There're lots of reasons behind these numbers. Need an analysis)

<pre><nowiki>#!CSV
Count;Answer
1;Unhappy (maybe more because I might have classified some into "Not so happy" instead of this category)
18;Not so happy
53;Happy
41;Very happy
 1;Completely ecstatic
</nowiki></pre>

== 18. How does GIT compare to other SCM tools you have used? ==
(There're lots of reasons behind these numbers. Need an analysis)

<pre><nowiki>#!CSV
Count;Answer
8;Worse
20;Equal (or uncomparable)
79;Better
</nowiki></pre>

== 19. What do you like about using GIT? ==
The most loved features are speed, distributed nature, visualization, merging, git design, branching

<pre><nowiki>#!CSV
Count;Answer;Note
      3; amend;git commit --amend
     19; branch; ease of branching, topic branch...
      3; cherry-picking;
      1; cli;
      2; collaboration; encourage collaboration
      1; color; git diff --color
      3; community;
     11; design;
     29; distributed;
      1; dump transport; can work with http only
      4; easy to use;
      3; everything;
      1; fast development;
      3; flexibility;
      5; free;GPL
      3; git bisect;
      2; git daemon;
      3; git diff;
      1; git grep;
      2; git log;
      2; git log -p;
      2; git log -S;
      1; git rev-parse syntax; HEAD, HEAD^2...
      1; git show;
      4; gitweb;
      1; history rewriting;
      1; http/webdav;
      1; implicit rename;
      1; index;
      1; integrity check;
     16; merge;
      3; patch;patch support, including git format-patch and friends, probably including stgit too
      1; rebase;
      1; sign off;
      2; simplicity;
      1; small;GIT binaries
      3; space;packs
     40; speed;
      1; stable;
      3; StGIT;
      9; unix philosophy;
     11; visualization;gitk, qgit and friends
      3; workflow;
</nowiki></pre>

== 20. What would you most like to see improved about GIT? (features, bugs, plugins, documentation, ...) ==

Note: I got dizzy digging into this answer set. I dropped some answers because I thought those were either not important nor vast. If someone is brave enough to review the raw data again and update this question, you are really welcome.

There are various ideas in the answers. Documentation related answers account the most (43 counts) followed by UI's (13) shallow/lazy/partial cloning (10), win32 native binaries, subproject support and some kind of plugins (all 9 counts).

<pre><nowiki>#!CSV
Count;Answer class;Note
     43;documentation; See below
     13;UI; See below
     10;shallow/lazy/partial cloning;
      9;win32 native binaries;
      9;subproject support;
      9;other kinds of plugins;See below
      7;remote repositories;See below
      6;merge-related;See below
      6;libification
      5;error-related;See below
      5;Eclipse plugin and others;
      4;GUI;Among others: gitk having the ability to graphically cherry pick fixes and initiate cleanup operations on the tree (rebasing to eliminate empty commits)
      4;git-undo;See below
      4;bugs;Just simply that, don't know what exact bug
      4;auto repack;
      3;rename;(It seems to be implemented already. We may need more documentation)
      3;gitweb;git-blame, something about header/footer templates so that people can change it without touching gitweb code
      3;design;incremental storage of changes for very big files. Redesign the git "backend storage", so that things like git-repack can go away. better objects store. Its better to have one BerkDB or GDBM file than 1000000 files named b5659bb2a599d0649871f56b59819c50 or whatever.
      2;portability;less dependency on script languages.  Non-ascii file name handing across machines and platforms (UTF-8 vs ISO-8859-1)
      2;performance;fast recursive merge strategy (almost done) and a packing strategy on memory-starved machines (<=256M)
      8;others;See below
</nowiki></pre>

Regarding to documentation. Here is some ideas:

* Make "The GIT Book"
* Comparison with other SCMs
* Common work flow cases simplified, especially WRT extracting patches for new development in the face of criss-crossed merges.
* consistency in command options (--blah=bluh and --blah bluh for example)
* Document <b>every</b> command options. git-diff options especially
* How to deal with failed merges
* Command classification: plumbing/porcelain/ancillary, C/Python/Bash, works on working tree/index/respository, manipulation/integration/syncing
* GIT server setup, GIT remote repository setup
* I'd like to see a tutorial that doesn't just teach you the commands, but walks you through the repository format and what it looks like; talk about the content-addressable filesystem, the various types of objects, how they work together, and what the commands change. I don't mean that this tutorial should show all the low-level plumbing commands; rather, it should what the porcelain commands do to the repo. I found that I understood GIT far better by understanding how it works.
* More recipe'like examples, with step by step instruction for various tasks.
* The documentation doesn't explain *why* I would ever use a command
* More workflow

As for UI:
* better/consistent look'n'feel (something SVN and darcs get very right)
* Cleaning up the user interface and separating the "porcelain" from the "plumbing". Hide plumbing parts from users and $PATH (keep them in /usr/lib/git for example)
* cogito-like frontend in main distribution
* don't provide several commands that does almost the same thing (git-am vs git-applymbox, git-blame vs git-annotate and so on) Merge them or keep the best version and get rid of the other one.
* I'd like to see "git-diff" mean something saner, namely a diff between the working copy and the last commit, like cg-diff
* increased verbosity about progresses. e.g. transfer rate or percentage. i have a slow connection and never know when it got stuck. another problem with slow connections is, that you cant resume a clone i.e. you transfer the complete repository with 14kb/s. on failure you have to restart; this sucks hugely
* PLEASE GOD FIX THE UI
* shortcuts for common commands (I think he meant default shortcuts)

The "other kinds of plugins" includes StGIT integration (3 counts), SCM integration (Subversion, Bazaar and Mercurial) and another comment for git-svn*:
* The SVN import tools can be difficult to use on some repostories like most of the ones on sourceforge that have been converted with cvs2git, and have a structure like trunk/projectA, trunk/projectB, branches/branchA/projectA, branches/branchA/projectB, which is a silly layout but seemingly common. This is difficult if I only want one of the projects, but want the branches and tags

Regarding to "remote repositories"
* better compression on the downloads
* better packing for dumb (HTTP-only) servers
* git-daemon with push support (+ seperate authentification database)
* git server over cgi
* Repository creation over HTTP/WebDAV
* I'd like to see an easier way to push changes to a remote repository on a machine without GIT installed. Pushing via SSH requires GIT installed on the remote machine. Currently, I get around this by using sshfs.
* Related to that, I'd like to see it made far easier to create a remote repository given a local one. Right now you have to create the remote repository first, possibly enable a hook (if HTTP access desired), set up a new remote to that repo, and then push. How about a new command that does all of that automatically; just run it with a repository URL, and optionally a name for the new remote branch, and it creates the remote repo, sets up the remote, optionally but by default enables the HTTP access hook, and pushes. Ideally, this functionality could become part of git-push, so that git-push creates the remote repo if it doesn't exist.

Here is merge-related comments:
* check for merge conflicts without actual merge (git-diff --show-conflicts <1> <2>)
* git-pull's behavior of merging in the first refspec to the current branch is very bad and has caused us serious repository issues in xorg.
* graphical merger (meld)
* Hierarhichal merges ala Accurev with a nice speedy GUI (Accurev's java gui is shit)

About error messages:
* error handling. I have couple times messed my repo so that I can't do Pull or push.
* make the error messages more helpful
* more error conditions and produce better diagnostics
* More helpful error messages.
* proper error messages that give some idea of what is going wrong.

There are some ideas about "git-undo":
* I'd also very much like to be able to use it in a sand-box mode where I can perform small commits for the sake of development and then roll some or all of them into a single changeset for pushing upstream.
* make it easy to undo things. Eg there is no generic "git-undo"
* '--undo' option for each command: 'git commit --undo' undoes the last commit, 'git update-index --undo' undoes the last update-index etc., so I don't have to remember how to undo that particular operation (was it --soft, --mixed, ^HEAD , or...)
* Would like the ability to more easily remove a bad commit from the middle of a tree (in many cases the tree is not the parent of any other tree so it should be harmless to reorder the later fixes).

Others include:
* patch handling (cherry picking). Migrating individual patches from one repository to another
* git-commit --review (as in cogito)
* I'd like to see *all* git commands work in subdirectories of the repository, and automatically go up until they find a .git directory
* Read settings from ~/.gitrc, then read the settings in a given repo. Many settings make more sense on a per-user basis rather than a per-repo basis, such as  the settings for git-imap-send
* Topic branch management

== 22.Documentation: Do you use the GIT wiki? If yes, do you find it useful? ==

<pre><nowiki>#!CSV
Count;Answer;Note
29;Don't use it;
57;No, it's not useful;Some answers were just "no" so they're probably either "no I don't use it" or "no it's not useful"
28;Yes, it's useful;
</nowiki></pre>

== 26. Getting help, staying in touch: Have you tried to get GIT help from other people? ==

<pre><nowiki>#!CSV
Count;Answer
67;Yes
45;No
</nowiki></pre>

== 27. If yes, did you get these problems resolved quickly and to your liking? ==

<pre><nowiki>#!CSV
Count;Answer
     49;Yes
     19;No
</nowiki></pre>

== 28. Do you subscribe to the mailing list? ==

<pre><nowiki>#!CSV
Count;Answer
    67;Yes
    49;No
</nowiki></pre>

== 29. If yes, do you find it useful, and traffic levels OK? ==

Two questions in one. So you're best bet.
<pre><nowiki>#!CSV
Count;Answer
      3; Not OK
     69;OK
</nowiki></pre>

== 30. Do you use the IRC channel (#git on irc.freenode.net)? ==

<pre><nowiki>#!CSV
Count;Answer
   22;Yes
   93;No
</nowiki></pre>

__NOTOC__