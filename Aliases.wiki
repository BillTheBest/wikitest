= Aliases =

With aliases, you can avoid typing the same commands over and over again. Aliases were added in Git version 1.4.0.

<b>Table of contents:</b>

<<<!-- ! TOC here -->(2)>>

----

= Simple =
== 'ci' ==
By adding the following section to <b>.git/config</b>, you can write <i>git ci</i> instead of <i>git commit</i>:

<pre><nowiki>
[alias]
        ci = commit
</nowiki></pre>
== 'ci', without editing .git/config ==
Some people are uncomfortable editing the config file themselves. They can edit the config by calling <i>git config alias.ci commit</i> instead.

== 'ci', in all local repositories ==
If you want to have the alias available everywhere on your local machine, you can either

- edit <b>$HOME/.gitconfig</b>, or - use the <i>--global</i> flag: <i>git config --global alias.ci commit</i>

== A shortcut for seeing the fetched commits ==
If you want to be able to say <i>git lc</i> to list all new commits after you fetched, with stats, but excluding merges, add this alias:

<pre><nowiki>
[alias]
        lc = log ORIG_HEAD.. --stat --no-merges
</nowiki></pre>

== Shortcut for displaying dates in your local timezone ==
Here's how to create an alias <i>git llog</i> that will behave just like <i>git log</i>, but will display dates in your local timezone.

<pre><nowiki>
[alias]
        llog = log --date=local
</nowiki></pre>

= Advanced =
Since version 1.5.0, Git supports aliases executing non-git commands, by prefixing the value with "!":

== Calling "find" ==
<pre><nowiki>
[alias]
        findobjects = !find -type f -name *.o
</nowiki></pre>
== Calling "gitk" ==
Since <i>gitk</i> does not follow the common form <i>git-<name></i>, and is no builtin either, you have to use the prefix "!" to call <i>gitk</i> from an alias:

<pre><nowiki>
[alias]

 . gitkconflict = !gitk --left-right HEAD...MERGE_HEAD
</nowiki></pre>

== Poor man's "stash" ==
A concatenation of git programs can also be achieved by the prefix "!":

<pre><nowiki>
[alias]
        stsh = !CURRENT=$(git symbolic-ref HEAD) && git symbolic-ref HEAD refs/heads/stash && git commit -a -m stashed && git checkout $CURRENT
</nowiki></pre>

== Serve repo on the spot ==
This fires up a git daemon for the repo you are currently in:

<pre><nowiki>
[alias]
        serve = !git daemon --reuseaddr --verbose  --base-path=. --export-all ./.git
</nowiki></pre>

It makes use of the fact that (currently, as of git 1.5.6.1) non-git alias are executed from the top-level dir of a repo. The simpler version

<pre><nowiki>
[alias]
        serve = daemon --reuseaddr --verbose  --base-path=. --export-all ./.git
</nowiki></pre>

works only when called from the top-level dir. In any case, you can connect simply by <i>git ls-remote git://127.0.0.1/</i> etc.

= Aliases with arguments =
Right from the start, aliases were meant as an easy way to avoid really simple, really short scripts.  Therefore, they can take arguments, which are appended to the command.

== 'ci' ==
That's right.  The simplest alias on this page takes arguments, so you can call:

<pre><nowiki>
$ git ci -m message file1 file2 dir1
</nowiki></pre>
= Advanced aliases with arguments =
Starting with version 1.5.3, git supports appending the arguments to commands prefixed with "!", too.  If you need to perform a reordering, or to use an argument twice, you can use this trick:

<pre><nowiki>
[alias]
        example = !sh -c 'ls $1 $0'
</nowiki></pre>
NOTE: the arguments start with $0, not with $1 as you are used from shell scripts.

== A 'debug' alias to help debugging builtins ==
When debugging builtins, you often use gdb to analyze the runtime state.  However, you have to disable the pager, and often you have to call the program with arguments.  If the program to debug is a builtin, you can use this alias:

<pre><nowiki>
[alias]
        debug = !GIT_PAGER= gdb --args git
</nowiki></pre>
Suppose you want to debug <i>git log HEAD..next</i>, you can call <i>gdb</i> by <i>git debug log HEAD..next</i> now.

== Calling "interdiff" between commits ==
If upstream applied a slightly modified patch, and you want to see the modifications, you should use the program <i>interdiff</i> of the <b>patchutils</b> package. Then you can add the alias <i>intercommit</i>:

<pre><nowiki>
[alias]
        intercommit = !sh -c 'git show "$0" > .git/commit1 && git show "$1" > .git/commit2 && interdiff .git/commit[12] | less -FRS'
</nowiki></pre>

== Getting the diff of only one function ==
Aliases can get pretty complicated.  For example when you want to see just the differences of one function in one file in two different commits, you can do this:

<pre><nowiki>
$ git config alias.funcdiff '!sh -c "git show \"\$0:\$2\" | sed -n \"/^[^ \t].*\$3(/,/^}/p\" > .tmp1 &&
        git show \"\$1:\$2\" | sed -n \"/^[^ \t].*\$3(/,/^}/p\" > .tmp2 &&
        git diff .tmp1 .tmp2"'   
</nowiki></pre>

The idea is to create two temporary files which contain only the function, and call <i>git diff</i> on them.  Use this alias this way: <i>git funcdiff <old-rev> <new-rev> <path> <function></i>.

= Collection of aliases by Git users =

Here is a collection of some Git users' aliases. If you know a simpler way to achieve the same, please add some notes.

== Editing/adding conflicted files ==

You get a lot of merge conflicts and want to quickly solve them using an editor and then add the conflicted files. Try this:

<pre><nowiki>
[alias]
        edit-unmerged = "!f() { git ls-files --unmerged | cut -f2 | sort -u ; }; vim `f`"
        add-unmerged = "!f() { git ls-files --unmerged | cut -f2 | sort -u ; }; git add `f`"
</nowiki></pre>

You should replace "vim" by your favorite editor.

Then just use 
<pre><nowiki>
$ git edit-unmerged
... edit ...
$ ... test ...
$ git add-unmerged
$ git commit  # or git rebase --continue or whatever
</nowiki></pre>

== Use graphviz for display ==

<pre><nowiki>
[alias]
        graphviz = "!f() { echo 'digraph git {' ; git log --pretty='format:  %h -> { %p }' \"$@\" | sed 's/[0-9a-f][0-9a-f]*/\"&\"/g' ; echo '}'; }; f"
</nowiki></pre>

This produces output that can be displayed using dotty, for example:
<pre><nowiki>
$ git graphviz HEAD~100..HEAD~60 | dotty /dev/stdin
$ git graphviz --first-parent master | dotty /dev/stdin
</nowiki></pre>

== Shortcuts ==

<pre><nowiki>
[alias]
    st = status
    ci = commit
    br = branch
    co = checkout
    df = diff
    lg = log -p
    who = shortlog -s --
</nowiki></pre>

== git k ==

If you use gitk in your git sessions quite frequently, you have perhaps misused your history and done:

<pre><nowiki>
$ gitk foo..bar
$ gitk checkout baz
</nowiki></pre>

Using `git k` instead of `gitk` may solve your problem:

<pre><nowiki>
[alias]
        k = !gitk
</nowiki></pre>

----
[[CategoryGitDocumentation]]

__NOTOC__