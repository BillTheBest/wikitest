<i>Note: This page is currently a work in progress.  It started out as a private email to someone who currently uses Subversion.  I decided to make it available and try to extend it further. I'll remove this comment when the page is better.  :)  -- Shawn Pearce</i>
----

Although this page is hosted on a Git-specific Wiki it tries to provide a fair and unbiased comparsion of Git and [http://subversion.tigris.org/ Subversion] to help perspective users of both tools better evaluate their choices.  This page only describes base Subversion and does not discuss the benefits and drawbacks to using [http://svk.elixus.org/ SVK], a distributed wrapper around Subversion.

= Git's Major Features Over Subversion =

There are a number of key features in Git that really make it stand out when compared to Subversion.  Among them are the following:

== Distributed ==

Git was designed from the ground up as a distributed version control system.  Being a distributed version control system means that multiple redundant repositories and branching are first class concepts of the tool.

In a distributed VCS like Git every user has a complete copy of the repository data stored locally, thereby making access to file history extremely fast.  It also means every user has a complete backup of the repository.  Have 20 users?  You probably have more than 20 complete backups of the repository as some users tend to keep more than one repository for the same project.  If any repository is lost due to system failure only the changes which were unique to that repository are lost.  If users frequently push and fetch changes with each other this tends to be an incredibly small amount of loss, if any.

In a centralized VCS like Subversion only the central repository has the complete history.  This means that users must communicate over the network with the central repository to obtain history about a file.  It also means that having 20 users does not automatically imply 20 active backups.  Backups must be maintained independently of the VCS.  If the central repository is lost due to system failure it must restored from backup and all changes since that last backup are likely to be lost.  Depending on the backup policies in place this could be several man-weeks worth of work.

== Branch Handling ==

Branches in Git are a core concept used everyday by every user.  In Subversion they are almost an afterthought and tend to be avoided unless absolutely necessary.

The reason branches are so core in Git is every developer's working directory is itself a branch.  Even if two developers are modifying two different unrelated files at the same time its easy to view these two different working directories as different branches stemming from the same common base revision of the project.

Consequently Git:

* Automatically tracks the project revision the branch started from.
    Knowing the starting point of a branch is necessary in order to successfully merge the branch back to the main trunk that it came from.
* Automatically records branch merge events.
    Merge records always include the following details:
* Who performed the merge.
* What branch(es) and revision(s) were merged.
      All changes made on the branch(es) remain attributed to the original authors and the original timestamps of those changes.
* What additional changes were made to complete the merge successfully.
      Any changes made during the merge that is beyond those made on the branch(es) being merged is attributed to the user performing the merge.
* When the merge was done
* Why the merge was done (<i>optional; can be supplied by the user</i>).
* Automatically starts the next merge at the last merge.
    Knowing what revision was last merged is necessary in order to successfully merge the same branches together again in the future.

This is quite contrary to Subversion's handling of branches.  As of Subversion 1.3:

* Automatically tracks the project revision the branch started from.
    Like Git Subversion remembers where a branch originated.
* Incomplete merge event record:
    Although Subversion records a merge as a commit and thus associates a username and a timestamp to it (like Git) there are some serious flaws in this record.
* All changes made on the branch appear to be made by the merging user.
      This means that from a historical perspective every line of code modified on the branch will appear in the trunk as though it was written by the user who merged the branch.  <i>This is wrong if there were other users working on that branch.</i>
* Its impossible to see only merge related changes.
      If the merging user had to modify 12 lines of code to complete the merge successfully you can't tell what those 12 lines were, or how those 12 lines differ from the versions on the branches being merged.
* The user must manually record what branches were merged and what versions they were.
      Unlike Git Subversion does not automatically include these details.  Consequently unless the user performing the merge explicitly includes these details in the commit message its impossible to know what exactly was merged.
* Does not track merge bases.
    Because Subversion does not record important details about a branch merge it cannot provide the new merge base on subsequent branch merges.  What this means in practice is that users must manually track branch merge points so subsequent merges can be completed.

In short Subversion's branching implementation is significantly flawed while Git's implementation accurately records the activity and is fully automatic.

== Performance (Speed of Operation) ==

Git is extremely fast.  Since all operations (except for push and fetch) are local there is no network latency involved to:

* Perform a diff.
* View file history.
* Commit changes.
* Merge branches.
* Obtain any other revision of a file (not just the prior committed revision).
* Switch branches.

FIXME: Include actual comparsions, e.g. load Git code into both Git and SVN.

== Small Space Requirements ==

Git's repository and working directory sizes are extremely small when compared to SVN.

For example the Mozilla repository is reported to be almost 12 GiB when stored in SVN using the fsfs backend.  The fsfs backend also requires over 240,000 files in one directory to record all 240,000 commits made over the 10 year history.  The exact same history is stored in Git by only two files totaling just over 420 MiB.  SVN requires 30x the disk space to store the same history.

An SVN working directory always contains two copies of each file: one for the user to actually work with and another hidden in the .svn/ to aid operations such as status, diff and commit.  In contrast a Git working uses only one small index file that stores around 100 bytes per tracked file.  On projects with a large number of files this can be a substantial difference in disk space required.

----
= Subversion's Major Features Over Git =

== User Interfaces ==

== Shorter Revision Numbers ==

== Single Repository ==

== Access Controls ==

== Line Ending Conversion ==

== Character Set Conversion ==

----
= The Original Email =
<i>Provided as reference, until this page is cleaned up.</i>

The key things that I like about Git are:

 - Its incredibly fast.
   No other SCM that I have used has been able to keep up with it, and I've used a lot, including Subversion, Perforce, darcs, [[BitKeeper]], [[ClearCase]] and CVS.

 - Its fully distributed.
   The repository owner can't dictate how I work.  I can create branches and commit changes while disconnected on my laptop, then later synchronize that with any number of other repositories.

 - Synchronization can occur over many media.
   An SSH channel, over HTTP via WebDAV, by FTP, or by sending emails holding patches to be applied by the recipient of the message.  A central repository isn't necessary, but can be used.

 - Branches are even cheaper than they are in Subversion.
   Creating a branch is as simple as writing a 41 byte file to disk.  Deleting a branch is as simple as deleting that file.

 - Unlike Subversion branches carry along their complete history.
   without having to perform a strange copy and walk through
   the copy.  When using Subversion I always found it awkward to
   look at the history of a file on branch that occurred before
   the branch was created.  <i>from #git: <robinr> spearce: I don't understand one thing about SVN in the page. I made a branch i SVN and browsing the history showed the whole history a file in the branch</i>

 - Branch merging is simpler and more automatic in Git.
   In Subversion you need to remember what was the last revision
   you merged from so you can generate the correct merge command.
   Git does this automatically, and always does it right.  Which
   means there's less chance of making a mistake when merging two
   branches together.

 - Branch merges are recorded as part of the proper history of the
   repository.  If I merge two branches together, or if I merge a
   branch back into the trunk it came from, that merge operation
   is recorded as part of the repostory history as having been
   performed by me, and when.  Its hard to dispute who performed
   the merge when its right there in the log.

 - Creating a repository is a trivial operation:
     mkdir foo; cd foo; git init-db
   That's it.  Which means I create a Git repository for everything
   these days.  I tend to use one repository per class.  Most of
   those repositories are under 1 MB in disk as they only store
   lecture notes, homework assignments, and my [[LaTeX]] answers.

 - The repository's internal file formats are incredible simple.
   This means repair is very easy to do, but even better because its
   so simple its very hard to get corrupted.  I don't think anyone
   has ever had a Git repository get corrupted.  I've seen Subversion
   with fsfs corrupt itself.  And I've seen Berkley DB corrupt itself
   too many times to trust my code to the bdb backend of Subversion.

 - Git's file format is very good at compressing data, despite
   its very simple format.  The Mozilla project's CVS repository
   is about 3 GB; its about 12 GB in Subversion's fsfs format.
   In Git its around 300 MB.

__NOTOC__