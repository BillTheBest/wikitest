(note: this currently covers only the first half of the talk)

Andrew:

Thank you, for coming everybody, some of you probably already
have heard of Linus Torvalds, those of you who haven't, you are
the people with Macintoshes on your laps.

He is a guy who delights being cruel to people.  His latest
cruelty is to create a revision control system which is
explicitly designed to make you feel less intelligent than you
thought you were.

Thank you for coming down today, Linus.  I've been getting
e-mails for the past few days from people saying "where is
Linus, why hasn't he merged my tree -- he does not love me
anymore".  And he walked in my office this afternoon, "what are
you doing here?"  Thank you taking the time off.  So Linus is
here today to explain to us why on earth he wrote a software
tool which, eh, and he is smart enough to know how to use.

[applause]

Linus:

So I have a few words of warning which is I do not actually do
speaking very much, partly because I do not like speaking,
partly because over the last few years everybody actually wants
me to talk about nebulous visions where the next century about
Linux, and I am a geek and I actually prefer talking about
technology.

So that's why I am not talking about the kernel, because it is
just too big to cram into a one hour talk although apparently
Andrew did that two days ago.  I am instead talking about git,
which is the source control management system that we use for
the kernel.

I am really really really bad at doing slides, which means that
if we actually end up following these slides, you will be bored
out of your mind. And the talk will probably not be very good
anyway, so I am the kind of speaker who really enjoys getting
questions, and if that means that we kind-of veer off in the
tangent, you'll be happier, I'll be happier and the talk will be
more interesting anyway.  I don't know how you do the things
here at Google talks, but I am just saying, don't feel shy as
far as I am concerned.  If your manager will shoot you, that's
your problem.

[shows "Credits" slide]

I want to give a few credits before I start.

Credit CVS in a very very negative way.  Because I, in many
ways, when I designed git, it's "what would Jesus do" except
that it's "what would CVS never ever do"-kind of approach to
source control management.  I've never actually used CVS for
the kernel. For the first 10 years of kernel maintenance, we
literally used tarballs and patches, which is a much superiour
source code management system than CVS is, but I did end up
using CVS for 7 years at a commercial company, and I hated it
with a passion.

When I say I hate CVS with a passion, I have to also say that if
there any SVN users (Subversion users) in the audience, you
might want to leave.  Because my hatred of CVS has meant that I
see Subversion as being the most pointless project ever started,
because the whole slogan for the Subversion for a while was 'CVS
done right' or something like that.  And if you start with that
kind of slogan, there is nowhere you can go.  It's like, there
is no way to do CVS right.

So that's the negative kind of credit.

Positive credit is [[BitKeeper]].  and I realize that a lot of
people thought there were a lot of strife over with [[BitKeeper]],
the parting was very painful in many ways.  As far as I am
concerned, the parting was amicable.  Even though it looked very
non-amicable to outsiders.  And [[BitKeeper]] was not only the first
source control system that I ever felt was worth using at all,
it was also the source control system that taught me why there
is a point to them, and how you actually can do things.

So git, in many ways, even though from a technical angle it is
very very different from [[BitKeeper]], which was another design
goal, because I wanted to make it clear that it wasn't a
[[BitKeeper]] clone, a lot of the flows we use with git come
directly from the flows we learned from [[BitKeeper]].  And I do not
think you use [[BitKeeper]] here inside Google?  As far as I know,
[[BitKeeper]] is the only commercial source control management
system that actually does distribution, and if you need a
commercial one, that's the one you should use for that reason.

And also I would like to point out that I've been doing git now
for slightly over two years, and while I started it, and I made
all the initial coding and design, it's actually been maintained
by a much more pleasant person, Junio Hamano, for the last year
and half, and he's really the person who actually made it more
approachable for mere mortals. Early versions of git did require
certain amount of brainpower to really wrap your mind around.
It's got much much easier since.  There's obviously the way I
always do everything is I try to do everybody else to do as much
as possible so I can sit back and sip my PiÃ±a Corada, so there
has been a lot of other people involved, too.

That's the credits.  With those out of the way.

[shows the "Content" slide]

So this slide is now one day old.  I didn't actually do the
slides last night because last night I was out ??crousing and
eating Sushi, but the slides will talk about implementation of a
realiable, high performance, distributed content management
thing, and the key word here is actually the "distributed" part.
I'll start off trying to explain why distribution is so
important.  If we never get past that point, I will actually be
happy.  If we never get to actually what git's implementation
internally is, it's fine.

I'm not also trying teach you how to use git.  There is this
thing called "google.com", what you do is, it has, you may have
seen it, it has this thing you can type things in, and you type
"git" and you press the "I'm feeling lucky" button, and you'll
actually get the homepage, the homepage has tutorials, it has
the user manual, they are all in HTML, if you actually want to
learn to use git, that's where you should start, not at this
talk.

But as I mentioned, if we actually start veering off topic
into other tangents because of questions, it's all good.

[shows "Content Advisory" slide]

I already gave you kind of a heads-up warning on this, I use the
term SCM, which I consider to mean "source code management",
that is revision control.  Some other people think SCM means
"software configuration management" and see it as a much bigger
feature including release management and stuff like that; that's
not what I am talking about, although git is clearly relevant in
that setting, too.

CVS, we already went there.

You can disagree with me as much as you want, but during this
talk, by definition, anybody who disagrees is stupid and ugly,
so keep that in mind.  When I am done speaking, you can go on
with your lives.  Right now, yes, I have strong opnions, and CVS
users, if you actually like using CVS, you shouldn't be here.
You should be in some mental institution, somewhere else.

So before actually I go and talk about the whole distribution
thing, which I think is the most important part, I'll talk a bit
about the background because it invariably comes up, because
people if they've heard about git, a lot of the things they've
heard about is the background for doing git in the first place.

[shows "Background" slide]

One piece of background information is I really am not a SCM
person.  I have never been very interested in revision control,
I thought it was evil, along with [[BitKeeper]], I actually credit
that to some degree for why git is so much better than
everything else, it is because my brain did not rot from years
and years of thinking CVS did something sane.

I needed a replacement for [[BitKeeper]]. The reason for that was
[[BitKeeper]] is a commercial product, but [[BitMover]] and Larry [[McVoy]]
allowed it to be used freely for open source projects, as some
of you may know, the only restriction was that you were not
supposed to reverse engineer it and you were not supposed to try
to create a competing product.  And I was happy with that,
because quite frankly as far as I am concerned, I do open source
because I think it is the only right way to do software, but at
the same time I would use the best tool for the job, and quite
frankly [[BitKeeper]] was it.  However, not everybody agreed with
me.  They are ugly and stupid, but they caused problems and it
resulted in the fact that Larry and I had several telephone
conversations, which ended up saying "ho, we'd all be much
happier if we just part ways and don't make this any worse"; so
we did.  And I made the Linux 2.6.12-rc2 release, about 2 years
ago, and said "I'm not going to touch Linux until I have a
replacement for [[BitKeeper]] for doing source code maintenance".
And one of the replacement options was going back to tarballs
and patches, but nobody really really liked that anymore.  So I
actually looked at a lot of alternatives.  Most of them I could
discard without even trying them out.  If you're not
distributed, you are not worth using, it's that simple.  If you
perform badly, you are not worth using, it is that simple.  And
if you cannot guarantee that the stuff I put into an SCM comes
out exactly the same, you are not worth using.  Quite frankly,
that pretty much took care of everything out there.

There are a lot of SCM systems that do not guarantee that what
you get out of it again is the same thing you put in.  If you
have a memory corruption, if you have a disc corruption, you may
never know.  The only way you know is you notice that there is
corruption in the files when you check them out.  And the source
code management system does not protect you at all.  And this is
not even uncommon.  It is very very common.

The performance issue -- one of the things I kind-of liked was a
system called Monotone, which actually I think there was a talk
at Google about them some time ago, I am not sure, it had a lot
of interesting ideas, but the performance was so horrendously
bad, that, I tried it for a day and realized that I cannot use
it.

The end result was that I decided I can write something better
than anything out there in two weeks, and I was right.

[shows "Distribution" (cheesy graphics) slide]

So, now we get to the distribution, and this is the worst slide
of them all, and I am not very proud of it, but the problem is
that distribution is really really important but when I try to
make slides about it, I could not do it.  And a part of it is my
obvious artistic talents, which are on display for all of you,
but a part of it is that it is really hard to explain.

So before I even start, I'd like to know, how many people are
used to the notion of a truly distrubuted source control
management system?

[audiences raise hands]

Are most of you kernel developers?  No?  Ok, so there were maybe
ten hands coming up.

Being distributed very much means that you do not have one
central location that keeps track of your data.  No single place
is more important than any other single place.  So for example
this is why I would never touch Subversion with a ten-foot pole.
There is a massive subversion repository and it's where
everybody has to write.  And the centralized model just does not
work when,... let's look at a few of the cases.

[shows "Distribution" (bullets) slide]

I say it's so much more than just off-line work, but the
off-line work part is actually maybe the most obvious thing,
which is that you can take a truly distributed source control
management system, you can take it on a plane and even if they
don't offer wi-fi and sattelite hookups, you just continue
working, you can look at all of your logs, you can commit, you
can do everything you would do even if you were connected to a
nice Gigabit ethernet directly to the backbone.  And that is
really important.  It is doubly important when you have hundreds
or thousands of people working on the same project, and they may
not be literally disconnected but in practice they aren't really
well connected either.  So part of distribution is this off-line
work theme, even if it is not completely off-line, it is
important to be able to do everything you want to do from any
location without having to be able to access the server.  What
that basic fact actually results in is that you effectively have
a lot more branching, because everybody who has a complete
repository and who can do commits on his own, will effectively
has his own branch, even if he does not realize it.  Even if you
think of your project as just having a single branch, every
single time you disconnect your laptop and start working with
it, you are on your own branch.  And this is really really
important and it is very different from anybody who is used to
CVS where branching is considered something that only true gurus
do.  How many of you have ever used CVS?

[audiences raise hands]

Ok, everybody.  How many of you have really done a branch and
ever merged it in CVS?

[audiences raise hands]

Good job.  I mean, it wasn't everybody, but it was actually more
than I expected.  How many of you enjoyed the experience?

[laughter]

Oooh, Ok, so there were a couple.  It is considered hard.  In
CVS when you merge a branch, I've done it, as little as possible
but I had to do it.  What you do is you plan ahead for a week,
and you basically set aside one day for doing it.  Am I wrong?
I am not seeing a lot of people saying "No, it was easy, and I
liked it".  It's horrible.

If you are distributed, you have to realize that every single
person has his own branch.  It's not horrible, it's not
something you even have to set up, it just is.  In fact, in git,
we like branches so much that a lot of people just have 5 or 10
or 15 of them, just because once you realize that you have to
have a special branch anyway, you might as well have many and
one of the branches you do some experimental work on, and one of
the branches you do maintenance on.  So branching is much more
inherent when you do distribution.

One of the other things that, to me, is important is that by
being distributed, you also automatically get to be slightly
more trustworthy.  I have a theory of backups, which is I do not
do them, I put stuff up on one site and everybody else mirrors
it, and if I crash my own machine, I don't really care, because
I can just download my own work right back.  And it works
beautifully well, and I do not have to have my own MIS
department.  I hardly suggest everybody else do the same.  But
this only really works in a distributed environment.  If you use
CVS, you cann't do this, if you use... what do you use here?
Perforce?  ... Perforce?  Eh ... I'm sorry.  I'm sure it's
better than CVS.

[audience laugh]

So that's part of it.  One of the really nice things which is
also, maybe you do not have this issue inside a company, but we
certainly have it in every single open source community I've
ever seen that uses CVS or Subversion or something like that is
that you have this notion of "commit access".  Because you have
a central repository, which means that everybody who is working
on that project needs to write to that central repository. Which
means that , since you do not want everybody to write to the
central repository because most people are morons, you create
this class of people who are ostensibly not morons.  And most of
the time what happens is that you make that class too small,
because it is really hard to know if a person is smart or not,
and even if you make it small, you will have problems.  So this
whole commit access issue, where some companies are able to
ignore by just giving everybody commit access, is a huge
psychological barrier and causes endless hours of politics in
most open source projects.

If you have a distributed model, it goes away.  Everybody has
commit access, you can do whatever you want to your project.
You just get your own branch, you do great work or you do stupid
work, nobody cares, it's your copy. It's your branch.  And later
on if it turns out that you did a good job, you can tell people,
"hey here is my branch, and by the way it performs 10x faster
than anybody else's branch, so nyah nyah nyah, how about pulling
from me?" And people do.  And that's actually how it works, and
we never have any politics, that's not quite true --- we have
other politics, but we do not have to worry about "commit
access" thing.  And I think this is a huge issue, and that alone
should mean that every single open source system should never
use anything but a distributed model.  You get rid of a lot of
issues.

One of the things that commercial companies, distributed model
actually help also with their relesase process.  You can have a
verification team that has its own tree.  And they pull from
people and they verify it and when they verified it they can
push it to the release team.  And say, "hey we have now verified
our version", and the development people they can go on playing
with their HEAD, instead of having to create tags, branches or
whatever you do to try to keep off each other's toes, again you
keep off each other's toes by every single group can have its
own tree and track its work and what they want done.  So
distributed is really really central to any SCM you should ever
use.

So get rid of Perforce, now.  

[applaud]

It's sad, but it is so so true.  And that was my only real slide
about distribution.  And I'd love to get questions, because we
are now moving into other areas.

Audience:

Question.  So how would you do it?  If you had this monstrously
awesomely big codebase and you wanted to use this without
stopping business for 6 months, how would you do it?

Linus:

Stay by the mic, because I could not make out your
question,... Ok, he went away.

How would you do this?  So, an example of actual distribution
is, you have a group of five people working on one small
particular feature.  And that means that for a while that
feature will be very very broken, right?  Because nobody
actually creates perfect code the first time around, except me,
but there is only one of me, right?  So what happens is they
want/need to have their own tree, that they can work in, without
affecting other people.  you can do this in many different ways.
In CVS one of the most common ways, because branches are so
painful is that you do not actually commit.  You never commit
until it passes every single test.  And then you have for
example at your company you have a very strict committing rule
saying you will never ever commit until it's passed the whole
test suite, and by the way the fact that the test suite takes
two hours to run, tough.

You cannot afford to commit. And this is something that happens
at every single company. I bet it happens even here at Google.
You probably have a strict testsuite and you are not supposed to
commit unless it passes, and then in practice, people make
one-liner changes and ignore the test suite because they know
the one-liner changes cannot possible break.  This happens.
This is a horrible horrible model.  It just means that you make
huge commits, because you commit something after you worked on
it for two weeks, and you have three people working in the same
sandbox because before they commit they cannot see the changes
that the other people made, this is common, it happens
everywhere, it's scary.

The other alternative is to use branches even in a centralized
environment, but branches always end up being pretty expensive
to do so you cannot do it for experimental features. You do not
know beforehand if something is gonna take one day or two weeks,
but most of the time most programmers say "hey, I can do this in
48 hours".  And it turns out, nah, no you couldn't.  But because
you feel you can do it in 48 hours, creating a branch, even in
systems that are better at creating branches than CVS is a big
pain.  So you don't do it because you think you can get it
resolved and you're back to case number 1, but if you decide to
create a branch, you will affect everybody else's repository,
because in a centralized environment, branches are global.  So
you're kind of screwing with everybody else but at least you are
not screwing with their main HEAD branch.  You are adding stuff
to their repositories but hopefully in a way that they won't
notice.  But it does make everybody's repositories bigger.

So either way, you can't win.

In constrast, in a distributed environment what you do is, you
have five people, they pull the current HEAD, which is hopefully
good and tested and they start working on it and they start
committing on it and you don't need to wait for two weeks until
your commits are stable, because your commits are always local.
And what happens is within that five people, you can pull from
each other.  That's what distributed means, there is no central
location, it means everybody is the same and you can merge
between yourselves, so not only can you commit every single line
if you want to, without having to run the two-hour testsuite,
but you can then communicate by pulling and merging each other's
work and one person finds a bug and commits it and tells the
other four people "hey, my repository has fix for this", and
then when that group is done two weeks later, they can tell
their manager, "hey we have done this, can you ask the main
group to pull and they will get this new feature, and by the way
we tested it over two weeks, and it works, and it performs this
much better because we have actually been able to time it before
even we ask anybody else to look at it".  And that is a hugely
better model for doing development.  And this is the model that
the kernel uses. It turns out that in many places we do not
need all that power. even in the kernel.  So people usually
don't pull within one group, but it does happen for example
the networking people sometimes affect the NFS people and 
the fact that they can synchronize actually helps.  So this is a
real practical advantage.

Somebody else has a question.

Audience:

It feels like the politics has just been moved to like an
indirect political question.  Everybody has an access and they
are all playing with their branches in their sandbox, but at the
end of the day, there has to be merging and resolving unless you
have 80 billion flavors of every Linux kernel.

Linus:

Absolutely.  So in practice you will never see, oh, there will
be a thousand or maybe twenty thousand different branches, but
in practice you won't ever see them because you won't care.  you
will see like a few main branches, maybe you'll see only one. in
the case of the kernel, a lot of people, they only ever look at
my branch. so even though there are lot of branches you can
ignore them.  what happens is that the way merging is done is
the way real security is done. by a network of trust.  if you
have ever done any security work, and it did not involve the
concept of network of trust, then it wasn't a security work.  I
don't know what you were doing but trust me, it's the only way
you can do security, and it's the only way you can do
development.  The way I work, I don't trust everybody.  in fact
I am a very cynical and untrusting person.  I think most of you
are completely imcompetent.  The whole point of being
distributed is I do not have to trust you, I do not have to give
you commit access.  But I know that among the multitude of
average people, there are some people that just stand out and I
trust, because I've been working with them.  I only need to
trust 5 10 15 people, if I have a network of trust that covers
those 5 10 15 people that are outstanding, and I know they are
outstanding, I can pull from them.  I do not have to spend a lot
of brainpower on the question.  When Andrew send me patches, he
actually does not use git, it's some kind of defect, but other
than that he is a very solid person.  When he asks me to pull,
he does it by sending million patches instead, I just do it.
Sometimes I disagree with some of these patches, but at some
point, trust means, ... never having to say you're sorry?  ... I
dunno ... It basically means that you have to accept other
people's decisions.  And the nice thing about trust is that it
does network.  That's where the network of trust comes in.  I
only need to trust a few people that much.  They have other
people, they have determined, hey, that guy is actually smarter
than I am, that's actually a really good measure of who you
should pull from.  If you have determined that somebody else is
smarter than you, go for it.  You can't lose.  Even if it turns
out that you pulled crap and somebody else starts complaining,
you know who you pulled from and you can just point to that
other person and say "hey, I just pulled, go to him, he knows
what he is doing".  That's how I work, that's how probably most
of my lieutenants work.  I pull the networking changes from one
person, he gets them from many other people that he's worked
with over time, so this is how it all comes together, it does
not have to come together to one point.  In the kernel it comes
together to one point largely i think for historical reasons,
and actually I've always tried to kind of encouraged people to
have more trees, so we do have vendor trees, we do have -mm
trees, we have multiple one points, and it happens to be that my
one point is getting maybe more attention than it always should.

Even if it doesn't come down to one point, it means that you can
take these thousands of branches, and ignore 99.9% of them.  And
you know, that hey, there are five branches that are really
interesting to follow because I am interested in those subareas.
And it all works very naturally.

One of the nice things about this whole network of trust is it's
not just easy to do techincally, it's actually how every single
person in this room is very fundamentally wired to work.  It is
how we think.  We do not know 100 people.  We have 5 7 10 close
personal friends, well, we are geeks so we have two, but that's
basically how humans work is that we have these people that we
really trust, it's family, it's close friends, and it really
fits, you do not even have to have a mental model, it fits how
we are wired up.  So there is a huge advantage of this whole
model of network of trust.

[31:00]

Audience:

Do you know of any companies that are using distributed systems
internally?  It seems like there might be a risk of kind-of
valcanizing the code base, as in people not being in the same
sandbox don't contribute back.

Linus:

So quite frankly there aren't that many distributed systems.
There is [[BitKeeper]], it is clearly being used at commercial
companies, we might have somebody in the audience who actually
knows but, what ... [comment from audience], so HP is using
things like [[BitKeeper]] for the printer project.  I am sure there
are lot more companies. In the open source world, there are two
distributed systems that are worth looking at.  One of them is
obviously git.  And you really should pick that one.  But the
other one is Mercurial, which pretty much has pretty much the
same design. There are huge differenses in implementation and
there are some differences in the detail, but it boils down to a
very similar model.  Git just does it better.  Everything else,
it's either centralized, or it's too unstable or too slow to use
for anything big.

Audience:

Is there an advantage for a company to have everybody playing in
the same sandbox?

Linus:

I think a lot of companies there is an advantage to that. I know
that inside companies, a lot of companies use git knowingly.  In
the sense that it is a company decision. I know several
companies who use git internally, not knowing that they do so
because they actually have their main repository in Subversion,
and a lot of developers then import it into git because git can
actually merge things for you.  So you can take a Subversion
tree, import into git, let git do the merge, which would be a
major headache to do in Subversion, create a merge commit, and
actually export it back to Subversion, and nobody else even knew
you used git. It's kind of sad, but we have cases of people
talking about doing exactly that inside companies. Git has not
been around in a form where a lot of people would be comfortable
using it for more than half a year or so, we have had so huge
improvements to the user interfaces that realistically a year
ago at commercial companies a lot of people would just have said
it's too hard to use. I think we are way past that hump. Git is
much easier to use than CVS, really. Most people tend to ... eh,
it's easier to use than anything else. It's just, ... get over
it.  You do not have to use all the powerful tools, some of them
might be things you would want to explain and introduce to
people only after they got over the initial hump of
understanding what the distribution really means, but the basic
stuff is really easy to do.

Audience:

One characteristic of a centralized system is that it's the
original developer who has to resolve any merges who has to fix
merges, how do you do that in git? and how do you minimize merge
conflicts?

Linus:

Thank you for asking me the question.  Did I tell you to ask
that question?

One of the really nice parts of git is that (a) git does make
things more,... much easier to merge than a lot of other
systems.  Merging a branch in CVS tends to be really painful.  I
merge,... one of my main statistics is that the kernel is
actually one of the biggest open source projects. we have 22,000
files. we've used git for two years. during those two years, we
have averaged 4.5 merges a day, every single day. That's not
something you do with something where merging is hard. So git
makes merging easy. But you will inevitably have cases where two
maintainers send me requests to "please pull my stuff" and I
pick one of them at random, usually because their mail happened
to be first in my mailbox, and I pull their stuff, and another
person had made changes that, it does not have happen that often
but it does happen, made changes that clashed so much that, I
said "I could fix this up, but I really don't want to". I did
not write the code, it's not my area of expertise, it's
networking or something like that, I cannot really judge it, I
cannot test it, so asking me to resolve the merge is just crazy,
it's not how you should do things. 

	Ok, the Windows machine freaked out again.

So what happens is, remember distribution means nobody is
special.  So instead of me merging, I just push out my first
tree, that did not have any merge issues, and I tell the second
person, "hey, I tried to pull from you, but I had merge
conflicts and they weren't completely trivial, so I decided you
get to do the honors instead."  And they do.  And they know what
they are doing because it's their changes.  So they can do the
merges and they probably think I am a moron because the merge
was so easy and it is obvious I should have taken their code,
but they do the merge and they update their tree, and say "hey,
can you pull from me now", and I pull from them and they did all
the work for me.  That's what is all about: they did all the
work for me.  So,... and I take the credit.  Now I just need to
figure out the step 3: profit.

That's kind of another thing that comes very naturally from
being distributed.  It's not something that is special to git.
Git makes merging easier than anything else, but git does it
exactly because git is distributed.

Audience:

I do not entirely understand why you think it is necessary to
have a distributed system to have,...  it seems like you get a
lot of the good effects, at least for a place like a corporate,
for open source development it seems very useful for everybody
can work on their own but, when you really have a centralized
corporate tree, then a centralized system with really cheap
branches wouldn't that give you pretty much the same effect?
Or is it just impossible to do?

Linus:

I will argue that centralized systems can't work, but it is
clearly true that if you are in a tightly controlled corporate
environment, centralized systems work better, and it is
unquestionably true that people have been able to use
centralized systems for the last 35 years. Nobody is really
arguing that centralized systems cannot work. They cannot work
as well as distributed systems.  One of the issues you tend to
have is centralized systems inevitably have problems when you
have groups in different locations. It tends to work really well
if you have a really beefy backbone fibre and I guess for Google
you probably do have some network going, I dunno, and maybe it
is not as big of an issue as it is for other projects, but trust
me, not having to go over the network for everything is a huge
performance saver. I do, ... this is, ... oh, I cannot show you
a demonstration

__NOTOC__