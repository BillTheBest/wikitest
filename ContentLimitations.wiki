Git is a <i>content</i> tracker, where <i>content</i> is de facto defined as "whatever is relevant to the state of a typical sourcecode tree". Basically, this is just files' data and "executable" attribute.

By design, git cannot track other aspects of the filesystem, including:

* File modes (except for the "executable" bit)
* File ownership
* File ACLs
* File modification and access times (these are set to checkout time)
* Extended attributes
* Empty directories
* Hard links
* Directories containing a subdirectory called ".git" (these may be tracked as submodules, but with very different semantics)
* Arbitrary files called ".gitignore" (these have special semantics)
* Arbitrary files called ".gitattributes" (these have special semantics)

Consequentially, Git cannot be directly used as a general versioning solution for arbitrary files, such as home directories or "/etc". In principle, it is possible to add a layer above git to convert the above information into "content" that Git can track. A crude and inefficient example would be to "tar" the whole directory and track the tar file as a single blob.

Some of the above items can be represented by tree objects in a git repository, but such tree objects are difficult or impossible to create using the standard git tools.

__NOTOC__